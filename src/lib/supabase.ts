import { createClient } from '@supabase/supabase-js';
import { projectId as defaultProjectId, publicAnonKey as defaultAnonKey } from '../utils/supabase/info';

// Use credentials from env vars (primary) or autogenerated info.tsx (fallback)
const envUrl = import.meta.env.VITE_SUPABASE_URL;
const envKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

const supabaseUrl = envUrl || `https://${defaultProjectId}.supabase.co`;
const supabaseAnonKey = envKey || defaultAnonKey;

// Log configuration status
if (typeof window !== 'undefined') {
  console.log('ðŸ”Œ Supabase Configuration:', {
    source: envUrl ? 'Environment Variables' : 'Default/Fallback',
    url: supabaseUrl,
    configured: !!(supabaseUrl && supabaseAnonKey)
  });
}

// Check if Supabase is configured
export const isSupabaseConfigured = !!(supabaseUrl && supabaseAnonKey && supabaseUrl !== '' && supabaseAnonKey !== '');

// Create Supabase client only if configured
export const supabase = isSupabaseConfigured
  ? createClient(supabaseUrl, supabaseAnonKey, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
        storage: typeof window !== 'undefined' ? window.localStorage : undefined,
      },
    })
  : null as any; // Fallback to null if not configured

// Export a getter function for components that need to create a client
export const getSupabaseClient = () => supabase;

// Log configuration status (only in development, silent mode)
if (typeof window !== 'undefined' && import.meta.env?.DEV) {
  if (isSupabaseConfigured) {
    console.log('âœ… Supabase connected');
  } else {
    console.log('ðŸ’¾ Local mode enabled');
  }
}

// Types
export interface UserProgressDB {
  id: string;
  user_id: string;
  level: number;
  xp: number;
  xp_to_next_level: number;
  streak: number;
  badges: string[];
  lessons_completed: number;
  total_lessons: number;
  current_lesson: number;
  last_activity: string;
  created_at: string;
  updated_at: string;
}

export interface UserActivity {
  id: string;
  user_id: string;
  activity_type: string;
  activity_description: string;
  xp_earned: number;
  created_at: string;
}

export interface TradingSimulation {
  id: string;
  user_id: string;
  simulation_data: any;
  profit_loss: number;
  btc_price_at_start: number;
  btc_price_at_end: number | null;
  status: 'active' | 'completed' | 'cancelled';
  created_at: string;
  completed_at: string | null;
}

export interface LeaderboardEntry {
  id: string;
  user_id: string;
  username: string;
  total_xp: number;
  level: number;
  streak: number;
  badges_count: number;
  rank: number;
  updated_at: string;
}

// New Types for Dashboard
export interface UserProfile {
  id: string; // matches auth.uid()
  full_name: string;
  avatar_url?: string;
  updated_at?: string;
}

export interface UserGamification {
  user_id: string;
  lessons_completed: number;
  quiz_score_total: number;
  trading_volume: number;
  updated_at?: string;
}

export interface DailyJournal {
  id: string;
  user_id: string;
  entry_date: string;
  trades_count: number;
  pnl: number;
  notes?: string;
  created_at?: string;
}

export interface AiTradingSignal {
  id: string;
  signal_type: 'buy' | 'sell' | 'hold';
  strike_price: number;
  premium: number;
  confidence: number;
  reasoning: string;
  created_at: string;
  symbol: string; // e.g., 'BTC'
}

// Helper Functions

export async function getUserProfile(userId: string): Promise<UserProfile | null> {
  if (!isSupabaseConfigured || !supabase) return null;
  try {
    const { data, error } = await supabase
      .from('user_profiles')
      .select('*')
      .eq('id', userId)
      .single();
    if (error) throw error;
    return data;
  } catch (err) {
    console.error('Error fetching user profile:', err);
    return null;
  }
}

export async function getUserGamification(userId: string): Promise<UserGamification | null> {
  if (!isSupabaseConfigured || !supabase) return null;
  try {
    const { data, error } = await supabase
      .from('user_gamification')
      .select('*')
      .eq('user_id', userId)
      .single();
    if (error) throw error;
    return data;
  } catch (err) {
    console.error('Error fetching gamification stats:', err);
    return null;
  }
}

export async function getDailyJournalStats(userId: string): Promise<{ totalTrades: number, totalPnL: number }> {
  if (!isSupabaseConfigured || !supabase) return { totalTrades: 0, totalPnL: 0 };
  try {
    const { data, error } = await supabase
      .from('trades')
      .select('total_premium, status')
      .eq('user_id', userId);

    if (error) {
      return { totalTrades: 0, totalPnL: 0 };
    }

    const rows = Array.isArray(data) ? data : [] as any[];
    const totalTrades = rows.length;
    const totalPnL = rows.reduce((acc: number, curr: { total_premium?: number }) => acc + (curr.total_premium || 0), 0);

    return { totalTrades, totalPnL };
  } catch {
    return { totalTrades: 0, totalPnL: 0 };
  }
}

export async function getLatestAiSignal(): Promise<AiTradingSignal | null> {
  if (!isSupabaseConfigured || !supabase) return null;
  try {
    const { data, error } = await supabase
      .from('ai_trading_signals')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(1)
      .single();
    if (error) throw error;
    return data;
  } catch (err) {
    console.error('Error fetching AI signal:', err);
    return null;
  }
}

export async function getUserProgress(userId: string): Promise<UserProgressDB | null> {
  if (!isSupabaseConfigured || !supabase) {
    return null;
  }

  try {
    const { data, error } = await supabase
      .from('user_progress')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error) {
      // Silently ignore table/column not found errors and SQL errors from missing schema
      const silentErrors = ['42P01', 'PGRST116', 'PGRST204', '42703', '42809'];
      const errorCode = error.code || '';
      if (!silentErrors.includes(errorCode)) {
        console.error('Error fetching user progress:', error);
      }
      return null;
    }

    return data;
  } catch (err) {
    // Silently catch any unexpected errors
    return null;
  }
}

export async function createUserProgress(userId: string, username: string): Promise<UserProgressDB | null> {
  if (!isSupabaseConfigured || !supabase) {
    return null;
  }

  try {
    const newProgress = {
      user_id: userId,
      level: 1,
      xp: 0,
      xp_to_next_level: 1000,
      streak: 0,
      badges: [],
      lessons_completed: 0,
      total_lessons: 15,
      current_lesson: 1,
    };

    const { data, error } = await supabase
      .from('user_progress')
      .insert(newProgress)
      .select()
      .single();

    if (error) {
      // Silently ignore table/column not found errors and SQL errors from missing schema
      const silentErrors = ['42P01', 'PGRST116', 'PGRST204', '42703', '42809'];
      const errorCode = error.code || '';
      if (!silentErrors.includes(errorCode)) {
        console.error('Error creating user progress:', error);
      }
      return null;
    }

    // Also create leaderboard entry (silently fail if table doesn't exist)
    await supabase.from('leaderboard_entries').insert({
      user_id: userId,
      username: username,
      total_xp: 0,
      level: 1,
      streak: 0,
      badges_count: 0,
    }).catch(() => {
      // Silently ignore if leaderboard table doesn't exist
    });

    return data;
  } catch (err) {
    // Silently catch any unexpected errors
    return null;
  }
}

export async function updateUserProgress(
  userId: string,
  updates: Partial<UserProgressDB>
): Promise<boolean> {
  if (!isSupabaseConfigured || !supabase) {
    return false;
  }

  try {
    const { error } = await supabase
      .from('user_progress')
      .update(updates)
      .eq('user_id', userId);

    if (error) {
      // Silently ignore table/column not found errors and SQL errors from missing schema
      const silentErrors = ['42P01', 'PGRST116', 'PGRST204', '42703', '42809'];
      const errorCode = error.code || '';
      if (!silentErrors.includes(errorCode)) {
        console.error('Error updating user progress:', error);
      }
      return false;
    }

    // Update leaderboard if XP or level changed
    if (updates.xp !== undefined || updates.level !== undefined) {
      try {
        const { data: progressData } = await supabase
          .from('user_progress')
          .select('xp, level, streak, badges')
          .eq('user_id', userId)
          .single();

        if (progressData) {
          // Update leaderboard (silently fail if table doesn't exist)
          await supabase
            .from('leaderboard_entries')
            .update({
              total_xp: progressData.xp,
              level: progressData.level,
              streak: progressData.streak,
              badges_count: progressData.badges?.length || 0,
            })
            .eq('user_id', userId)
            .catch(() => {
              // Silently ignore if leaderboard table doesn't exist
            });

          // Recalculate ranks (silently fail if function doesn't exist)
          await supabase.rpc('update_leaderboard_ranks').catch(() => {
            // Silently ignore if RPC function doesn't exist
          });
        }
      } catch {
        // Silently ignore errors when updating leaderboard
      }
    }

    return true;
  } catch (err) {
    // Silently catch any unexpected errors
    return false;
  }
}

export async function addUserActivity(
  userId: string,
  activityType: string,
  description: string,
  xpEarned: number
): Promise<boolean> {
  if (!isSupabaseConfigured || !supabase) return false;

  try {
    const { error } = await supabase.from('user_activities').insert({
      user_id: userId,
      activity_type: activityType,
      activity_description: description,
      xp_earned: xpEarned,
    });

    if (error) {
      // Silently ignore all errors for user activities
      // This is a non-critical feature that gracefully degrades when DB schema is missing
      return false;
    }

    return true;
  } catch (err) {
    // Silently catch any unexpected errors
    return false;
  }
}

export async function getUserActivities(userId: string, limit = 10): Promise<UserActivity[]> {
  if (!isSupabaseConfigured || !supabase) return [];

  try {
    const { data, error } = await supabase
      .from('user_activities')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .limit(limit);

    if (error) {
      // Silently ignore table/column not found errors and SQL errors from missing schema
      const silentErrors = ['42P01', 'PGRST116', 'PGRST204', '42703', '42809'];
      const errorCode = error.code || '';
      if (!silentErrors.includes(errorCode)) {
        console.error('Error fetching user activities:', error);
      }
      return [];
    }

    return data || [];
  } catch (err) {
    // Silently catch any unexpected errors
    return [];
  }
}

export async function getLeaderboard(limit = 50): Promise<LeaderboardEntry[]> {
  if (!isSupabaseConfigured || !supabase) return [];

  try {
    const { data, error } = await supabase
      .from('leaderboard_entries')
      .select('*')
      .order('total_xp', { ascending: false })
      .limit(limit);

    if (error) {
      // Silently ignore table/column not found errors and SQL errors from missing schema
      // 42P01: undefined_table, PGRST116: not found, PGRST204: column not found
      // 42703: undefined_column, 42809: SQL function/aggregate errors
      const silentErrors = ['42P01', 'PGRST116', 'PGRST204', '42703', '42809'];
      const errorCode = error.code || '';
      if (!silentErrors.includes(errorCode)) {
        console.error('Error fetching leaderboard:', error);
      }
      return [];
    }

    return data || [];
  } catch (err) {
    // Catch any unexpected errors
    return [];
  }
}

export async function saveTradingSimulation(
  userId: string,
  simulationData: any,
  btcPriceStart: number
): Promise<string | null> {
  if (!isSupabaseConfigured || !supabase) return null;

  try {
    const { data, error } = await supabase
      .from('trading_simulations')
      .insert({
        user_id: userId,
        simulation_data: simulationData,
        btc_price_at_start: btcPriceStart,
        status: 'active',
      })
      .select('id')
      .single();

    if (error) {
      // Silently ignore table/column not found errors and SQL errors from missing schema
      const silentErrors = ['42P01', 'PGRST116', 'PGRST204', '42703', '42809'];
      const errorCode = error.code || '';
      if (!silentErrors.includes(errorCode)) {
        console.error('Error saving simulation:', error);
      }
      return null;
    }

    return data.id;
  } catch (err) {
    // Silently catch any unexpected errors
    return null;
  }
}

export async function completeTradingSimulation(
  simulationId: string,
  profitLoss: number,
  btcPriceEnd: number
): Promise<boolean> {
  if (!isSupabaseConfigured || !supabase) return false;

  try {
    const { error } = await supabase
      .from('trading_simulations')
      .update({
        profit_loss: profitLoss,
        btc_price_at_end: btcPriceEnd,
        status: 'completed',
        completed_at: new Date().toISOString(),
      })
      .eq('id', simulationId);

    if (error) {
      // Silently ignore table/column not found errors and SQL errors from missing schema
      const silentErrors = ['42P01', 'PGRST116', 'PGRST204', '42703', '42809'];
      const errorCode = error.code || '';
      if (!silentErrors.includes(errorCode)) {
        console.error('Error completing simulation:', error);
      }
      return false;
    }

    return true;
  } catch (err) {
    // Silently catch any unexpected errors
    return false;
  }
}
